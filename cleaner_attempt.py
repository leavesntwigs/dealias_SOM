# -*- coding: utf-8 -*-
"""cleaner_attempt.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10xgq9TO0TClp_nMbIL2_bb8NxwJaSjhb
"""

import tensorflow as tf
import numpy as np
 
class SOM(object):
    def __init__(self, x, y, input_dim, learning_rate, radius, num_iter=111):
        
        #Initialize properties
        self._x = x
        self._y = y
        self._learning_rate = float(learning_rate)
        self._radius = float(radius)
        self._num_iter = num_iter
        self._graph = tf.Graph()
 
        #Initialize graph
        with self._graph.as_default():
            
            #Initializing variables and placeholders
            self._weights = tf.Variable(tf.random_normal([x*y, input_dim]))
            self._locations = self._generate_index_matrix(x, y)
            self._input = tf.placeholder("float", [input_dim])
            self._iter_input = tf.placeholder("float")
 
            #Calculating BMU
            input_matix = tf.stack([self._input for i in range(x*y)])
            distances = tf.sqrt(tf.reduce_sum(tf.pow(tf.subtract(self._weights, input_matix), 2), 1))
            bmu = tf.argmin(distances, 0)
            
            #Get BMU location
            mask = tf.pad(tf.reshape(bmu, [1]), np.array([[0, 1]]))
            size = tf.cast(tf.constant(np.array([1, 2])), dtype=tf.int64)
            bmu_location = tf.reshape(tf.slice(self._locations, mask, size), [2])
 
            #Calculate learning rate and radius
            decay_function = tf.subtract(1.0, tf.div(self._iter_input, self._num_iter))
            _current_learning_rate = tf.multiply(self._learning_rate, decay_function)
            _current_radius = tf.multiply(self._radius, decay_function)
 
            #Adapt learning rate to each neuron based on position
            bmu_matrix = tf.stack([bmu_location for i in range(x*y)])
            bmu_distance = tf.reduce_sum(tf.pow(tf.subtract(self._locations, bmu_matrix), 2), 1)
            neighbourhood_func = tf.exp(tf.negative(tf.div(tf.cast(bmu_distance, "float32"), tf.pow(_current_radius, 2))))
            learning_rate_matrix = tf.multiply(_current_learning_rate, neighbourhood_func)
 
            #Update all the weights
            multiplytiplier = tf.stack([tf.tile(tf.slice(
                learning_rate_matrix, np.array([i]), np.array([1])), [input_dim])
                                               for i in range(x*y)])
            delta = tf.multiply(
                multiplytiplier,
                tf.subtract(tf.stack([self._input for i in range(x*y)]), self._weights))                
                         
            new_weights = tf.add(self._weights, delta)
            self._training = tf.assign(self._weights, new_weights)                                       
 
            #Initilize session and run it
            self._sess = tf.Session()
            initialization = tf.global_variables_initializer()
            self._sess.run(initialization)
 
    def train(self, input_vects):
        for iter_no in range(self._num_iter):
            for input_vect in input_vects:
                self._sess.run(self._training,
                               feed_dict={self._input: input_vect,
                                          self._iter_input: iter_no})
 
        self._centroid_matrix = [[] for i in range(self._x)]
        self._weights_list = list(self._sess.run(self._weights))
        self._locations = list(self._sess.run(self._locations))
        for i, loc in enumerate(self._locations):
            self._centroid_matrix[loc[0]].append(self._weights_list[i])
  
    def map_input(self, input_vectors):
        return_value = []
        for vect in input_vectors:
            min_index = min([i for i in range(len(self._weights_list))],
                            key=lambda x: np.linalg.norm(vect - self._weights_list[x]))
            return_value.append((self._locations[min_index], self._weights_list[min_index]))
            # return_value.append(self._locations[min_index])
        return return_value
    
    def _generate_index_matrix(self, x,y):
        return tf.constant(np.array(list(self._iterator(x, y))))
    
    def _iterator(self, x, y):
        for i in range(x):
            for j in range(y):
                yield np.array([i, j])
                           
    def get_weights(self):
      return self._weights_list

somfold = SOM(12, 3, 3, 2, 20, 100)

training_data = [[261.752, 2.625, -3.0], [48.2767, 2.375, 3.0], [158.766, 3.125, -4.5], [127.752, 3.875, -1.5], [326.775, 4.125, 3.5], [116.26, 2.875, -1.5], [71.2518, 2.125, 1.5], [294.252, 2.125, 2.5], [194.268, 4.125, -7.5], [192.25, 3.875, -7.5], [19.7479, 2.125, 4.0], [252.749, 4.375, -5.5], [45.7718, 4.875, 4.5], [192.752, 3.875, -8.0], [14.7739, 2.875, 5.0], [113.766, 2.875, 5.5], [338.25, 4.375, 5.5], [249.752, 4.625, -6.5], [162.26, 3.875, -4.5], [183.255, 3.375, -5.5], [281.25, 2.375, -9.5], [39.2459, 2.375, 4.0], [248.275, 2.875, 25.0], [349.264, 4.875, 5.5], [169.247, 2.625, -5.5], [1.26617, 2.125, 4.5], [187.762, 4.625, -7.5], [4.26819, 2.625, 5.5], [210.751, 4.625, -9.0], [256.284, 2.875, -4.0], [317.758, 2.375, 2.5], [136.758, 3.625, -2.0], [208.765, 3.375, -8.0], [47.2522, 3.875, 4.0], [201.248, 2.125, -5.5], [199.753, 3.125, -5.0], [317.758, 4.375, 2.5], [81.2549, 3.375, 10.0], [289.251, 2.125, 2.0], [193.749, 2.125, -2.0], [336.272, 4.875, 4.5], [325.753, 3.875, 4.0], [160.746, 4.625, -4.5], [236.25, 4.625, 9.0], [303.253, 3.875, 0.5], [306.749, 3.375, 2.0], [305.25, 3.625, 2.5], [203.253, 4.375, -10.0], [219.754, 4.125, -9.0], [347.272, 2.375, 4.5], [144.772, 2.625, -4.5], [138.277, 3.125, -3.5], [311.745, 3.125, 3.0], [224.783, 3.875, -8.0], [192.752, 3.875, -8.0], [116.26, 3.375, 12.0], [25.2823, 4.375, 5.5], [245.248, 2.875, -5.5], [74.7455, 2.625, 2.0], [212.248, 4.625, -8.0], [16.7569, 2.875, 5.5], [208.765, 3.625, -8.5], [260.75, 4.375, -5.0], [237.263, 3.625, -6.0], [175.248, 3.625, -5.5], [349.753, 4.875, 4.5], [58.255, 3.125, 7.0], [31.7807, 3.875, 5.0], [244.745, 3.125, -6.0], [301.748, 4.875, 1.5], [200.748, 4.375, -7.5], [229.252, 4.375, -7.0], [327.25, 3.375, 3.5], [337.25, 2.625, 3.5], [320.271, 4.625, 3.0], [313.745, 3.125, 2.0], [337.758, 3.125, 4.0], [199.265, 3.875, -7.0], [234.75, 2.375, -3.5], [205.249, 4.875, -8.0], [212.764, 2.625, -6.0], [94.2545, 2.375, 1.0], [194.268, 3.125, -7.0], [300.265, 2.625, 2.0], [261.249, 2.625, -3.5], [61.2625, 4.625, 3.5], [233.281, 2.875, -6.0], [208.765, 2.875, -7.5], [205.249, 4.625, -8.0], [216.233, 2.625, -7.5], [278.251, 2.375, 10.5], [273.255, 3.125, -2.5], [305.25, 2.625, 3.0], [321.751, 4.875, 3.5], [94.7763, 4.375, 1.0], [104.247, 3.125, -10.0], [94.7763, 3.125, 1.0], [208.765, 2.375, 5.0], [119.254, 3.625, -1.0], [169.758, 2.375, -4.5]]

somfold.train(training_data)

#ray0 =  [[ 261.752, 2.625, -3.0 ], [48.2767, 2.375, 3.0], [158.766, 3.125, -4.5]]
ray0 = [[ 76.745 , 2.125 , 2.500 ], 
[ 76.745 , 2.375 , 2.500 ], 
[ 76.745 , 2.625 , 10.500 ], 
[ 76.745 , 2.875 , 10.500 ], 
[ 76.745 , 3.125 , -12.000 ], 
[ 76.745 , 3.375 , -12.000 ], 
[ 76.745 , 3.625 , -12.000 ], 
[ 76.745 , 3.875 , -12.000 ], 
[ 76.745 , 4.125 , -12.000 ], 
[ 76.745 , 4.375 , -12.000 ],]

mapping = somfold.map_input(ray0)

mapping

len(mapping)
for tuple in mapping:
  print(tuple)

count = len(mapping)
idx = 0
Nyquist = 5
for tuple in mapping:

  grid_loc, something = tuple
  print("observation: ", ray0[idx])
  print("mapped to = ", something)
  az = something[0]
  range = something[1]
  ve = something[2]            # expected value
  az0, range0, va = ray0[idx]  # va = apparent value
  # add or subtract 2*Nyq until within range of expected value, ve
  v0 = va
  upperbound = ve + 2.*Nyquist
  lowerbound = ve - 2.*Nyquist
  while (v0 < lowerbound):
    v0 = v0 + 2.*Nyquist
  while (v0 > upperbound):
    v0 = v0 - 2.*Nyquist
  vr = v0
  print("unfolded: az=", az0, " range=", range0, " vr=", vr, " ve=", ve)
  idx += 1



# weights = somfold.get_weights()
rayfolded =  [[ 77.2504 , 2.125 , 3.000 ], [ 77.2504 , 2.375 , 3.000 ], [ 77.2504 , 2.625 , 4.500 ], [ 77.2504 , 2.875 , 4.500 ], [ 77.2504 , 3.125 , 11.500 ], [ 77.2504 , 3.375 , 11.500 ], [ 77.2504 , 3.625 , 12.000 ], [ 77.2504 , 3.875 , 12.000 ], [ 77.2504 , 4.125 , -12.000 ], [ 77.2504 , 4.375 , -12.000 ]]


mapping2 = somfold.map_input(rayfolded)

mapping2